Now, for the modules.

Each module is a separate set of functionality. As the name implies, one should be working perfectly fine without the other. Of course, there are classes shared and stuff, but the functionality provided by the module should be unhampered if one of the others is missing. (Indeed, there are thoughts about spreading the project into various downloads.)

As said, the basic interface is "IAnathemaModule".
6 methods are provided in there, I'll cover them one by one.
initAnathemaResources(IAnathemaResources resources):
    Loads the resource files required for internationalization. Inside anathema, all strings are represented by abstracts, that are translated into the user's preferred language by this mechanism. Have a look at one of the *.properties files in one of the various "resources/language" folders and CTRL-LeftClick on one of the entries there to see how it looks within the program.

initItemTypes(IItemTypeRegistry itemRegistry):
    Each module can register itemtypes with the registry. Items are characters, series, charm cascades... basically anything that's diplayed in a tab of it's own. If the item is persistable, it goes into the new and load menus, if not, it is rendered as an entry in 'Extras'.

initModel(IAnathemaModel anathemaModel):
    In the basic implementation, creates the persisters for the item types used by the module. In extend versions (CharacterModule for example), the character sheets used by the different types of characters are registered with the model.

public void initPresentation(IAnathemaPresentation presentation, IAnathemaView anathemaView):
    Launches the presentation for this module by creating additional menu entries and adding toolbar icons.

Finally, there are 4 methods dealing with extension points. The concept is somewhat abstract to me, but I'll explain to the best of my abilities. Extension points are basically hooks in a module where other modules can hang stuff on. Other modules afterwards can walk up to that hooks and take the stuff, doing whatever they like to it.
One simple kind of extension points are the Menuextension points - in core module provides them, so that every module can create entries in the new and load menus without relying on the rather limited functionality provided by the core module itself and without publishing lots and lots of methods.
Another possible application for extension points is the preferences system (I'm working on it being an application of it, at least). Once it's done, core module will provide a preferences extension point and every present and future module will be able to register new actions to display in the preferences dialogue.

For each type of extension point there's a "init" and a "fill" method, so that the registration at the extension points can take place after initialization but before the point is 'executed' by the owning module.

That concludes our tour. 